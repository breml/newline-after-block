package deferpattern

import (
	"fmt"
	"os"
)

// Test 1: Basic pattern - if err != nil followed by defer (should NOT warn)
func basicDeferAfterErrorCheck() error {
	file, err := os.Open("example.txt")
	if err != nil {
		return err
	}
	defer file.Close()

	fmt.Println("processing file")
	return nil
}

// Test 2: Multiple consecutive defers after error check (should NOT warn)
func multipleConsecutiveDefers() error {
	file, err := os.Open("example.txt")
	if err != nil {
		return err
	}
	defer file.Close()
	defer fmt.Println("cleanup")

	fmt.Println("processing file")
	return nil
}

// Test 3: Defer followed by regular statement without blank line (SHOULD warn)
func deferFollowedByStatementNoBlankLine() error {
	file, err := os.Open("example.txt")
	if err != nil {
		return err
	}
	defer file.Close() // want "missing newline after block statement"

	data := []byte("test")

	fmt.Println(data)
	return nil
}

// Test 4: Defer followed by regular statement with blank line (should NOT warn)
func deferFollowedByStatementWithBlankLine() error {
	file, err := os.Open("example.txt")
	if err != nil {
		return err
	}
	defer file.Close()

	data := []byte("test")

	fmt.Println(data)
	return nil
}

// Test 5: Defer followed by block statement without blank line (SHOULD warn)
func deferFollowedByBlockNoBlankLine() error {
	file, err := os.Open("example.txt")
	if err != nil {
		return err
	}
	defer file.Close() // want "missing newline after block statement"

	if true {
		fmt.Println("in block")
	}

	return nil
}

// Test 6: Defer followed by block statement with blank line (should NOT warn)
func deferFollowedByBlockWithBlankLine() error {
	file, err := os.Open("example.txt")
	if err != nil {
		return err
	}
	defer file.Close()

	if true {
		fmt.Println("in block")
	}

	return nil
}

// Test 7: Non-error-check if followed by defer (SHOULD warn)
func nonErrorCheckIfFollowedByDefer() {
	x := 5
	if x > 0 {
		fmt.Println("positive")
	} // want "missing newline after block statement"

	defer fmt.Println("cleanup")

	fmt.Println("done")
}

// Test 8: if err == nil (wrong operator) followed by defer (SHOULD warn)
func wrongOperatorFollowedByDefer() error {
	file, err := os.Open("example.txt")
	if err == nil {
		fmt.Println("success")
	} // want "missing newline after block statement"

	defer fmt.Println("cleanup")

	fmt.Println(file)
	return nil
}

// Test 9: if with different variable name followed by defer (SHOULD warn)
func differentVariableNameFollowedByDefer() error {
	file, e := os.Open("example.txt")
	if e != nil {
		return e
	} // want "missing newline after block statement"

	defer file.Close()

	fmt.Println(file)
	return nil
}

// Test 10: Nested - defer after error check inside another block (should NOT warn)
func nestedDeferAfterErrorCheck() {
	if true {
		file, err := os.Open("example.txt")
		if err != nil {
			fmt.Println(err)
			return
		}
		defer file.Close()

		fmt.Println("processing")
	}
}

// Test 11: Error check if not followed by defer (SHOULD warn - normal behavior)
func errorCheckNotFollowedByDefer() error {
	file, err := os.Open("example.txt")
	if err != nil {
		return err
	} // want "missing newline after block statement"

	fmt.Println(file)
	return nil
}

// Test 12: Multiple defers followed by statement without blank line (SHOULD warn)
func multipleDefersThenStatementNoBlankLine() error {
	file, err := os.Open("example.txt")
	if err != nil {
		return err
	}
	defer file.Close()
	defer fmt.Println("cleanup") // want "missing newline after block statement"

	data := []byte("test")

	fmt.Println(data)
	return nil
}

// Test 13: Defer at end of function (should NOT warn)
func deferAtEnd() error {
	file, err := os.Open("example.txt")
	if err != nil {
		return err
	}
	defer file.Close()

	return nil
}

// Test 14: if nil != err pattern (reversed operands) followed by defer (should NOT warn)
func reversedOperandsFollowedByDefer() error {
	file, err := os.Open("example.txt")
	if nil != err {
		return err
	}
	defer file.Close()

	fmt.Println("processing file")
	return nil
}

// Test 15: Standalone defer statements (should NOT warn between them)
func standaloneConsecutiveDefers() {
	defer fmt.Println("first")
	defer fmt.Println("second")
	defer fmt.Println("third")

	fmt.Println("body")
}

// Test 16: Standalone defer followed by statement without blank line (SHOULD warn)
func standaloneDeferFollowedByStatementNoBlankLine() {
	defer fmt.Println("cleanup") // want "missing newline after block statement"

	x := 5

	fmt.Println(x)
}

// Test 17: Standalone defer followed by statement with blank line (should NOT warn)
func standaloneDeferFollowedByStatementWithBlankLine() {
	defer fmt.Println("cleanup")

	x := 5

	fmt.Println(x)
}
